# sit323-737-2024-t1-prac7p

Task Implementation Details
1. Installed MongoDB in Kubernetes
I created a Deployment and Service manifest for MongoDB to deploy it as a standalone pod inside the cluster. This setup ensures MongoDB is available for the application to connect and store data.

2. Created MongoDB User and Kubernetes Secret
To secure MongoDB, I created a user and stored the credentials inside a Kubernetes Secret. These secrets were injected as environment variables into the MongoDB and application pods.

3. Configured Persistent Storage
To ensure MongoDB retains data even after restarts, I created a Persistent Volume (PV) and a Persistent Volume Claim (PVC). These volumes were mounted inside the MongoDB pod to provide durable storage.

4. Updated Application Deployment
I modified the deployment manifest of my microservice to include the necessary environment variables for database connection, including database name, host, and credentials fetched from the Kubernetes Secret.

5. Connected Node.js Application to MongoDB
Inside the application code, I used the mongoose library to connect to MongoDB using the environment variables from the Kubernetes configuration. I structured the connection logic to handle errors and reconnect automatically if needed.

6. Tested CRUD Operations
I created and tested API routes in the microservice to perform basic Create, Read, Update, and Delete operations. These tests confirmed that the application was successfully reading and writing data to MongoDB.

Overview
In this task, I integrated a MongoDB database into my existing containerized microservice application deployed in a Kubernetes cluster. The main purpose of this integration was to enable persistent storage and data management for dynamic content generated by the application. This involved setting up the database, securing credentials, configuring storage, and ensuring connectivity with the application.
